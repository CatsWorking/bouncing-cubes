<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bouncing Cubes</title>
<style>
  html,body {
    height:100%;
    margin:0;
    font-family: Inter, Roboto, Arial, sans-serif;
    background: linear-gradient(180deg, #0f172a 0%, #071027 100%);
    color: #fff;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  /* Full-screen canvas container */
  .stage {
    position: relative;
    width: 100%;
    height: 100vh;
    overflow: hidden;
  }

  /* Center button */
  .center-btn {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%,-50%);
    z-index: 20;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 14px 22px;
    border-radius: 12px;
    background: linear-gradient(135deg,#06b6d4,#7c3aed);
    box-shadow: 0 10px 30px rgba(0,0,0,0.4), 0 2px 8px rgba(124,58,237,0.25);
    color: white;
    font-weight:600;
    cursor: pointer;
    user-select: none;
    border: none;
    outline: none;
  }
  .center-btn:active { transform: translate(-50%,-50%) scale(0.98); }

  /* small control row */
  .controls {
    position: absolute;
    z-index: 25;
    left: 12px;
    top: 12px;
    display:flex;
    gap:8px;
    align-items:center;
  }
  .control {
    background: rgba(255,255,255,0.06);
    border-radius:8px;
    padding:8px 10px;
    color:#e2e8f0;
    font-size:13px;
    backdrop-filter: blur(4px);
  }

  /* attribution (optional) */
  .attribution {
    position: absolute;
    bottom: 12px;
    right: 12px;
    color: rgba(255,255,255,0.6);
    font-size: 12px;
    z-index:20;
  }

  canvas {
    display:block;
    width:100%;
    height:100%;
  }

  /* responsive - shrink button on small screens */
  @media (max-width:420px) {
    .center-btn { padding:10px 14px; font-size:14px; border-radius:10px; }
  }
</style>
</head>
<body>
  <div class="stage" id="stage">
    <button id="spawnBtn" class="center-btn">Spawn 10 Bouncing Cubes</button>

    <div class="controls">
      <div class="control" id="countLabel">Cubes: 0</div>
      <div class="control" id="fpsLabel">FPS: 0</div>
    </div>

    <div class="attribution">Click the button â€” cubes will bounce inside the viewport.</div>

    <canvas id="c"></canvas>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  let DPR = Math.max(1, window.devicePixelRatio || 1);

  function resize() {
    DPR = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(canvas.clientWidth * DPR);
    canvas.height = Math.floor(canvas.clientHeight * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize, { passive:true });
  resize();

  // Cube model: each cube is drawn as a front rectangle + top and right faces (simple 3D illusion)
  class Cube {
    constructor(x,y,size, vx, vy, color) {
      this.x = x;
      this.y = y;
      this.size = size;
      this.vx = vx;
      this.vy = vy;
      this.color = color;
      this.rotation = Math.random()*Math.PI*2;
      this.angularVel = (Math.random()-0.5)*0.06;
      this.bounceDamping = 0.9;
    }
    step(dt, boundsW, boundsH) {
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.rotation += this.angularVel * dt;

      // simple gravity toggle (very mild)
      this.vy += 220 * dt * 0.0; // set 0.0 to remove gravity; keep tiny if you want: e.g. 0.2

      // bounce off edges
      const half = this.size/2;
      // left
      if (this.x - half < 0) {
        this.x = half;
        this.vx = -this.vx * this.bounceDamping;
      }
      // right
      if (this.x + half > boundsW) {
        this.x = boundsW - half;
        this.vx = -this.vx * this.bounceDamping;
      }
      // top
      if (this.y - half < 0) {
        this.y = half;
        this.vy = -this.vy * this.bounceDamping;
      }
      // bottom
      if (this.y + half > boundsH) {
        this.y = boundsH - half;
        this.vy = -this.vy * this.bounceDamping;
      }
    }
    draw(ctx) {
      const s = this.size;
      const x = this.x;
      const y = this.y;

      // choose shading colors
      const front = this.color;
      const top = shade(front, 18);   // lighter
      const right = shade(front, -18);// darker

      // rotation visual: rotate the cube slightly around center
      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(this.rotation);
      ctx.translate(-x, -y);

      // compute cube vertices for simple 3-faced box: front rect centered at (x,y)
      const half = s/2;
      // front face
      ctx.beginPath();
      ctx.rect(x-half, y-half, s, s);
      ctx.fillStyle = front;
      ctx.fill();
      ctx.closePath();

      // top face polygon (a parallelogram)
      ctx.beginPath();
      ctx.moveTo(x-half, y-half);                   // front-left
      ctx.lineTo(x, y-half - s*0.5);                // back-left (upwards)
      ctx.lineTo(x+half, y-half - s*0.5);           // back-right (upwards)
      ctx.lineTo(x+half, y-half);                   // front-right
      ctx.closePath();
      ctx.fillStyle = top;
      ctx.fill();

      // right face polygon (a parallelogram)
      ctx.beginPath();
      ctx.moveTo(x+half, y-half);
      ctx.lineTo(x+half + s*0.5, y);                // right-back
      ctx.lineTo(x+half + s*0.5, y + s);            // right-bottom-back
      ctx.lineTo(x+half, y+half);
      ctx.closePath();
      ctx.fillStyle = right;
      ctx.fill();

      // subtle outline
      ctx.lineWidth = Math.max(0.6, s * 0.02);
      ctx.strokeStyle = 'rgba(0,0,0,0.22)';
      ctx.strokeRect(x-half, y-half, s, s);

      ctx.restore();
    }
  }

  // simple color shading utility: lighten/darken hex color by percent
  function shade(hex, percent) {
    // accept #rrggbb
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    const p = percent/100;
    const nr = Math.min(255, Math.max(0, Math.round(r + (p * 255))));
    const ng = Math.min(255, Math.max(0, Math.round(g + (p * 255))));
    const nb = Math.min(255, Math.max(0, Math.round(b + (p * 255))));
    return `rgb(${nr},${ng},${nb})`;
  }

  // small palette
  const palette = [
    '#06b6d4', '#7c3aed', '#ef4444', '#f59e0b', '#10b981', '#3b82f6', '#ec4899'
  ];

  let cubes = [];

  function spawnN(n) {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    for (let i=0;i<n;i++){
      const size = 28 + Math.random()*56; // 28 - 84 px
      const x = Math.random() * (w - size) + size/2;
      const y = Math.random() * (h - size) + size/2;
      const speed = 120 + Math.random()*240;
      const angle = Math.random()*Math.PI*2;
      const vx = Math.cos(angle) * speed;
      const vy = Math.sin(angle) * speed;
      const color = palette[Math.floor(Math.random()*palette.length)];
      cubes.push(new Cube(x,y,size,vx,vy,color));
    }
    updateCounters();
  }

  // UI
  const spawnBtn = document.getElementById('spawnBtn');
  const countLabel = document.getElementById('countLabel');
  const fpsLabel = document.getElementById('fpsLabel');

  spawnBtn.addEventListener('click', () => {
    spawnN(10);
  });

  function updateCounters() {
    countLabel.textContent = `Cubes: ${cubes.length}`;
  }

  // main loop
  let last = performance.now();
  let fpsSmoothed = 60;
  function loop(now) {
    const dt = Math.min(0.05, (now - last) / 1000); // cap dt at 50ms
    last = now;

    // physics step
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    for (let c of cubes) c.step(dt, w, h);

    // clear
    ctx.clearRect(0,0, canvas.width, canvas.height);

    // draw background subtle vignette
    drawBackground(ctx, canvas.clientWidth, canvas.clientHeight);

    // draw cubes sorted by y to give slight depth
    cubes.sort((a,b)=> (a.y - b.y));
    for (let c of cubes) c.draw(ctx);

    // remove tiny cubes with almost zero motion? (not necessary)
    // update FPS
    const fps = 1 / dt;
    fpsSmoothed = fpsSmoothed * 0.92 + fps * 0.08;
    fpsLabel.textContent = `FPS: ${Math.round(fpsSmoothed)}`;

    requestAnimationFrame(loop);
  }

  requestAnimationFrame(loop);

  // Fancy background (just a subtle gradient + vignette)
  function drawBackground(ctx, w, h) {
    // gradient
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,'rgba(6,7,23,0.6)');
    g.addColorStop(1,'rgba(2,6,23,0.9)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // soft vignette
    const rad = Math.max(w,h) * 0.8;
    const vg = ctx.createRadialGradient(w/2,h/2, rad*0.02, w/2,h/2, rad);
    vg.addColorStop(0, 'rgba(255,255,255,0.0)');
    vg.addColorStop(0.7, 'rgba(0,0,0,0.06)');
    vg.addColorStop(1, 'rgba(0,0,0,0.25)');
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,w,h);
  }

  // Initialize by resizing when DOM content loaded and whenever stage size changes
  function measureStageAndResizeCanvas(){
    // Canvas clientWidth/Height is automatically CSS size; just ensure pixel backing fits
    resize();
  }
  window.addEventListener('load', measureStageAndResizeCanvas);
  measureStageAndResizeCanvas();

  // allow clearing with double-click anywhere
  window.addEventListener('dblclick', () => {
    cubes = [];
    updateCounters();
  });

  // optional: spawn small amount periodically to keep things interesting (disabled by default)
  // setInterval(()=>spawnN(1), 3000);

})();
</script>
</body>
</html>
