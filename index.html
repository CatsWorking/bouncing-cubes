<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bouncing Cubes â€” Sandbox</title>
<style>
  html,body { height:100%; margin:0; font-family: Inter, Roboto, Arial, sans-serif;
    background: #0f172a; color:#fff; }

  .stage { position: relative; width:100%; height:100vh; overflow:hidden; }
  canvas { position:absolute; top:0; left:0; width:100%; height:100%; display:block; }
  #gameCanvas { z-index:5; }
  #drawCanvas { z-index:10; cursor:crosshair; }

  .center-btn {
    position:absolute; left:50%; top:50%; transform:translate(-50%,-50%);
    z-index:20; padding:14px 22px; border-radius:12px;
    background:linear-gradient(135deg,#06b6d4,#7c3aed);
    color:white; font-weight:600; cursor:pointer; border:none;
  }
  .credit {
    position:absolute; left:50%; top:calc(50% + 60px); transform:translateX(-50%);
    z-index:20; font-size:14px; color:rgba(255,255,255,0.75);
    text-align:center; max-width:80%;
  }
  .controls {
    position:absolute; left:12px; top:12px; z-index:25;
    display:flex; flex-direction:column; gap:6px;
    background:rgba(0,0,0,0.35); padding:8px 12px; border-radius:10px;
    backdrop-filter:blur(6px);
    font-size:13px;
  }
  .draw-controls {
    position:absolute; bottom:12px; right:12px; z-index:30;
    background:rgba(0,0,0,0.5); padding:10px; border-radius:10px;
    display:flex; flex-direction:column; gap:8px;
  }
  input[type="range"] { width:120px; }
</style>
</head>
<body>
<div class="stage">
  <button id="spawnBtn" class="center-btn">Spawn 10 Cubes</button>
  <div class="credit">made by sushi [thx jj for the nickname] or br33z3 as i call myself online</div>

  <div class="controls">
    <div id="countLabel">Cubes: 0</div>
    <div id="fpsLabel">FPS: 0</div>
    <label>Gravity <input id="gravitySlider" type="range" min="200" max="8000" value="3000" step="100"></label>
    <label>Cube Size <input id="cubeSizeSlider" type="range" min="20" max="100" value="50"></label>
    <label>Render Scale <input id="renderScaleSlider" type="range" min="50" max="100" value="100"></label>
    <label><input type="checkbox" id="bloomToggle"> Bloom</label>
  </div>

  <canvas id="gameCanvas"></canvas>
  <canvas id="drawCanvas"></canvas>

  <div class="draw-controls">
    <button id="toggleDraw">Enable Collision Drawing Mode</button>
    <div id="drawTools" style="display:none;">
      <label>Brush size: <input type="range" id="brushSize" min="2" max="40" value="10"></label>
      <label>Color: <input type="color" id="brushColor" value="#ffffff"></label>
      <button id="clearDrawings">Clear Drawings</button>
    </div>
  </div>
</div>

<script>
(() => {
  // Canvases
  const gameCanvas = document.getElementById('gameCanvas');
  const gctx = gameCanvas.getContext('2d');
  const drawCanvas = document.getElementById('drawCanvas');
  const dctx = drawCanvas.getContext('2d');

  // Offscreen buffer for render scaling
  const buffer = document.createElement("canvas");
  const bctx = buffer.getContext("2d");

  let GRAVITY = 3000;
  let cubeBaseSize = 50;
  let renderScale = 1.0;
  let bloomEnabled = false;

  // Controls
  document.getElementById("gravitySlider").addEventListener("input", e => GRAVITY = +e.target.value);
  document.getElementById("cubeSizeSlider").addEventListener("input", e => cubeBaseSize = +e.target.value);
  document.getElementById("renderScaleSlider").addEventListener("input", e => renderScale = +e.target.value / 100);
  document.getElementById("bloomToggle").addEventListener("change", e => bloomEnabled = e.target.checked);

  function resize() {
    [gameCanvas, drawCanvas].forEach(cv=>{
      cv.width = cv.clientWidth;
      cv.height = cv.clientHeight;
    });
  }
  window.addEventListener('resize', resize);
  resize();

  // Cube model
  class Cube {
    constructor(x,y,size,vx,vy,color){
      this.x=x; this.y=y; this.size=size;
      this.vx=vx; this.vy=vy;
      this.color=color;
    }
    step(dt, boundsW, boundsH, lines){
      this.vy += GRAVITY * dt;
      this.x += this.vx * dt;
      this.y += this.vy * dt;

      const r = this.size/2;
      if(this.x-r<0){this.x=r;this.vx*=-0.8;}
      if(this.x+r>boundsW){this.x=boundsW-r;this.vx*=-0.8;}
      if(this.y-r<0){this.y=r;this.vy*=-0.8;}
      if(this.y+r>boundsH){this.y=boundsH-r;this.vy*=-0.7;this.vx*=0.98;}

      // Check drawn lines
      for(let line of lines){
        if(lineCollision(this,line)){
          this.vy = -this.vy*0.7;
          this.vx *= 0.8;
        }
      }
    }
    draw(ctx){
      ctx.save();
      if(bloomEnabled){
        ctx.shadowBlur = 20;
        ctx.shadowColor = this.color;
      }
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x-this.size/2, this.y-this.size/2, this.size, this.size);
      ctx.restore();
    }
  }

  function lineCollision(cube,line){
    const {x,y,size}=cube; const r=size/2;
    const dx=line.x2-line.x1; const dy=line.y2-line.y1;
    const lenSq=dx*dx+dy*dy;
    let t=((x-line.x1)*dx+(y-line.y1)*dy)/lenSq;
    t=Math.max(0,Math.min(1,t));
    const nx=line.x1+t*dx, ny=line.y1+t*dy;
    const distSq=(x-nx)*(x-nx)+(y-ny)*(y-ny);
    return distSq<r*r;
  }

  const palette=['#ff5f6d','#ffc371','#47e495','#00c6ff','#7f00ff','#ff61d2'];
  let cubes=[];
  let lines=[];

  function spawnN(n){
    const w=gameCanvas.clientWidth;
    for(let i=0;i<n;i++){
      const size=cubeBaseSize + (Math.random()-0.5)*10;
      const x=Math.random()*(w-size)+size/2;
      const y=size/2+Math.random()*20;
      const vx=(Math.random()-0.5)*200;
      const vy=0;
      const color=palette[Math.floor(Math.random()*palette.length)];
      cubes.push(new Cube(x,y,size,vx,vy,color));
    }
    countLabel.textContent=`Cubes: ${cubes.length}`;
  }

  const spawnBtn=document.getElementById('spawnBtn');
  const countLabel=document.getElementById('countLabel');
  const fpsLabel=document.getElementById('fpsLabel');
  spawnBtn.addEventListener('click',()=>spawnN(10));

  // Drawing mode
  const toggleDraw=document.getElementById("toggleDraw");
  const drawTools=document.getElementById("drawTools");
  const brushSize=document.getElementById("brushSize");
  const brushColor=document.getElementById("brushColor");
  const clearDrawings=document.getElementById("clearDrawings");
  let drawingMode=false,drawing=false,lastX=0,lastY=0;

  toggleDraw.addEventListener("click",()=>{
    drawingMode=!drawingMode;
    drawTools.style.display=drawingMode?"flex":"none";
    toggleDraw.textContent=drawingMode?"Disable Drawing Mode":"Enable Collision Drawing Mode";
  });

  clearDrawings.addEventListener("click",()=>{
    dctx.clearRect(0,0,drawCanvas.width,drawCanvas.height);
    lines=[];
  });

  drawCanvas.addEventListener("mousedown",e=>{
    if(!drawingMode)return;
    drawing=true;[lastX,lastY]=[e.offsetX,e.offsetY];
  });
  drawCanvas.addEventListener("mouseup",()=>drawing=false);
  drawCanvas.addEventListener("mouseleave",()=>drawing=false);
  drawCanvas.addEventListener("mousemove",e=>{
    if(!drawingMode||!drawing)return;
    const [x,y]=[e.offsetX,e.offsetY];
    dctx.strokeStyle=brushColor.value;
    dctx.lineWidth=brushSize.value;
    dctx.lineCap="round";
    dctx.beginPath(); dctx.moveTo(lastX,lastY); dctx.lineTo(x,y); dctx.stroke();
    lines.push({x1:lastX,y1:lastY,x2:x,y2:y});
    [lastX,lastY]=[x,y];
  });

  // Cube-to-cube collisions
  function resolveCubeCollisions(){
    for(let i=0;i<cubes.length;i++){
      for(let j=i+1;j<cubes.length;j++){
        const a=cubes[i],b=cubes[j];
        const dx=b.x-a.x,dy=b.y-a.y;
        const dist=Math.sqrt(dx*dx+dy*dy);
        const minDist=(a.size+b.size)/2;
        if(dist<minDist&&dist>0){
          const overlap=0.5*(minDist-dist);
          const nx=dx/dist, ny=dy/dist;
          a.x-=nx*overlap; a.y-=ny*overlap;
          b.x+=nx*overlap; b.y+=ny*overlap;
          const va=a.vx*nx+a.vy*ny;
          const vb=b.vx*nx+b.vy*ny;
          const diff=va-vb;
          a.vx-=diff*nx; a.vy-=diff*ny;
          b.vx+=diff*nx; b.vy+=diff*ny;
        }
      }
    }
  }

  // Game loop
  let last=performance.now(),fpsSmoothed=60,accumulator=0;
  function loop(now){
    const frameTime=(now-last)/1000; last=now;
    accumulator+=frameTime;
    const step=1/60;
    while(accumulator>=step){
      for(let c of cubes) c.step(step,gameCanvas.clientWidth,gameCanvas.clientHeight,lines);
      resolveCubeCollisions();
      accumulator-=step;
    }

    // set buffer resolution based on renderScale [bro i wanna f myself so bad broo]
    buffer.width = Math.floor(gameCanvas.width * renderScale);
    buffer.height = Math.floor(gameCanvas.height * renderScale);

    bctx.setTransform(renderScale,0,0,renderScale,0,0);
    bctx.clearRect(0,0,gameCanvas.width,gameCanvas.height);

    drawBackground(bctx,gameCanvas.width,gameCanvas.height);
    cubes.forEach(c=>c.draw(bctx));
    bctx.setTransform(1,0,0,1,0,0);

    // Blit buffer scaled to full canvas
    gctx.clearRect(0,0,gameCanvas.width,gameCanvas.height);
    gctx.drawImage(buffer, 0,0,gameCanvas.width,gameCanvas.height);

    const fps=1/frameTime;
    fpsSmoothed=fpsSmoothed*0.9+fps*0.1;
    fpsLabel.textContent=`FPS: ${Math.round(fpsSmoothed)}`;
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function drawBackground(ctx,w,h){
    const g=ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,'#0f172a'); g.addColorStop(1,'#020617');
    ctx.fillStyle=g; ctx.fillRect(0,0,w,h);
  }
})();
</script>
</body>
</html>
