<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  let DPR = Math.max(1, window.devicePixelRatio || 1);

  function resize() {
    DPR = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(canvas.clientWidth * DPR);
    canvas.height = Math.floor(canvas.clientHeight * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize, { passive:true });
  resize();

  // Cube model with strong gravity
  class Cube {
    constructor(x,y,size, vx, vy, color) {
      this.x = x;
      this.y = y;
      this.size = size;
      this.vx = vx;
      this.vy = vy;
      this.color = color;
      this.rotation = Math.random()*Math.PI*2;
      this.angularVel = (Math.random()-0.5)*0.06;
      this.bounceDamping = 0.75; // lose some energy on bounce
    }
    step(dt, boundsW, boundsH) {
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.rotation += this.angularVel * dt;

      // ðŸ’¥ strong gravity
      this.vy += 2000 * dt; 

      const half = this.size/2;

      // left/right walls
      if (this.x - half < 0) {
        this.x = half;
        this.vx = -this.vx * 0.9;
      }
      if (this.x + half > boundsW) {
        this.x = boundsW - half;
        this.vx = -this.vx * 0.9;
      }

      // top
      if (this.y - half < 0) {
        this.y = half;
        this.vy = -this.vy * 0.9;
      }

      // bottom
      if (this.y + half > boundsH) {
        this.y = boundsH - half;
        this.vy = -this.vy * this.bounceDamping;
      }
    }

    draw(ctx) {
      const s = this.size;
      const x = this.x;
      const y = this.y;

      const front = this.color;
      const top = shade(front, 18);
      const right = shade(front, -18);

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(this.rotation);
      ctx.translate(-x, -y);

      const half = s/2;
      ctx.beginPath();
      ctx.rect(x-half, y-half, s, s);
      ctx.fillStyle = front;
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(x-half, y-half);
      ctx.lineTo(x, y-half - s*0.5);
      ctx.lineTo(x+half, y-half - s*0.5);
      ctx.lineTo(x+half, y-half);
      ctx.closePath();
      ctx.fillStyle = top;
      ctx.fill();

      ctx.beginPath();
      ctx.moveTo(x+half, y-half);
      ctx.lineTo(x+half + s*0.5, y);
      ctx.lineTo(x+half + s*0.5, y + s);
      ctx.lineTo(x+half, y+half);
      ctx.closePath();
      ctx.fillStyle = right;
      ctx.fill();

      ctx.lineWidth = Math.max(0.6, s * 0.02);
      ctx.strokeStyle = 'rgba(0,0,0,0.22)';
      ctx.strokeRect(x-half, y-half, s, s);

      ctx.restore();
    }
  }

  function shade(hex, percent) {
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    const p = percent/100;
    const nr = Math.min(255, Math.max(0, Math.round(r + (p * 255))));
    const ng = Math.min(255, Math.max(0, Math.round(g + (p * 255))));
    const nb = Math.min(255, Math.max(0, Math.round(b + (p * 255))));
    return `rgb(${nr},${ng},${nb})`;
  }

  const palette = [
    '#06b6d4','#7c3aed','#ef4444','#f59e0b','#10b981','#3b82f6','#ec4899'
  ];

  let cubes = [];

  function spawnN(n) {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    for (let i=0;i<n;i++){
      const size = 28 + Math.random()*56;
      const x = Math.random() * (w - size) + size/2;
      const y = Math.random() * (h/4); // spawn near top so they fall
      const vx = (Math.random()-0.5)*400;
      const vy = (Math.random()-0.5)*200;
      const color = palette[Math.floor(Math.random()*palette.length)];
      cubes.push(new Cube(x,y,size,vx,vy,color));
    }
    updateCounters();
  }

  const spawnBtn = document.getElementById('spawnBtn');
  const countLabel = document.getElementById('countLabel');
  const fpsLabel = document.getElementById('fpsLabel');

  spawnBtn.addEventListener('click', () => {
    spawnN(10);
  });

  function updateCounters() {
    countLabel.textContent = `Cubes: ${cubes.length}`;
  }

  let last = performance.now();
  let fpsSmoothed = 60;
  function loop(now) {
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;

    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    for (let c of cubes) c.step(dt, w, h);

    ctx.clearRect(0,0, canvas.width, canvas.height);
    drawBackground(ctx, w, h);

    cubes.sort((a,b)=> (a.y - b.y));
    for (let c of cubes) c.draw(ctx);

    const fps = 1 / dt;
    fpsSmoothed = fpsSmoothed * 0.92 + fps * 0.08;
    fpsLabel.textContent = `FPS: ${Math.round(fpsSmoothed)}`;

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function drawBackground(ctx, w, h) {
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,'rgba(6,7,23,0.6)');
    g.addColorStop(1,'rgba(2,6,23,0.9)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);
  }

  function measureStageAndResizeCanvas(){ resize(); }
  window.addEventListener('load', measureStageAndResizeCanvas);
  measureStageAndResizeCanvas();

  window.addEventListener('dblclick', () => {
    cubes = [];
    updateCounters();
  });
})();
</script>
