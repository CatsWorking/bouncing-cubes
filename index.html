<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bouncing Cubes — Gravity</title>
<style>
  html,body {
    height:100%;
    margin:0;
    font-family: Inter, Roboto, Arial, sans-serif;
    background: linear-gradient(180deg, #0f172a 0%, #071027 100%);
    color: #fff;
    -webkit-font-smoothing:antialiased;
    -moz-osx-font-smoothing:grayscale;
  }

  .stage {
    position: relative;
    width: 100%;
    height: 100vh;
    overflow: hidden;
  }

  .center-btn {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%,-50%);
    z-index: 20;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 14px 22px;
    border-radius: 12px;
    background: linear-gradient(135deg,#06b6d4,#7c3aed);
    box-shadow: 0 10px 30px rgba(0,0,0,0.4), 0 2px 8px rgba(124,58,237,0.25);
    color: white;
    font-weight:600;
    cursor: pointer;
    user-select: none;
    border: none;
    outline: none;
  }
  .center-btn:active { transform: translate(-50%,-50%) scale(0.98); }

  .controls {
    position: absolute;
    z-index: 25;
    left: 12px;
    top: 12px;
    display:flex;
    gap:8px;
    align-items:center;
  }
  .control {
    background: rgba(255,255,255,0.06);
    border-radius:8px;
    padding:8px 10px;
    color:#e2e8f0;
    font-size:13px;
    backdrop-filter: blur(4px);
  }

  .attribution {
    position: absolute;
    bottom: 12px;
    right: 12px;
    color: rgba(255,255,255,0.6);
    font-size: 12px;
    z-index:20;
  }

  canvas { display:block; width:100%; height:100%; }

  @media (max-width:420px) {
    .center-btn { padding:10px 14px; font-size:14px; border-radius:10px; }
  }
</style>
</head>
<body>
  <div class="stage" id="stage">
    <button id="spawnBtn" class="center-btn">Spawn 10 Bouncing Cubes</button>

    <div class="controls">
      <div class="control" id="countLabel">Cubes: 0</div>
      <div class="control" id="fpsLabel">FPS: 0</div>
    </div>

    <div class="attribution">Click the button — cubes will fall under gravity and bounce.</div>

    <canvas id="c"></canvas>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  // physics constants (change these if you want even more/less gravity)
  const GRAVITY = 3000;         // px / s^2 (large value = strong gravity)
  const FLOOR_RESTITUTION = 0.72; // bounce energy retained on floor (0..1)
  const WALL_RESTITUTION = 0.85;  // bounce on walls/top
  const FLOOR_FRICTION = 0.995;   // horizontal friction while on floor

  let DPR = Math.max(1, window.devicePixelRatio || 1);

  function resize() {
    DPR = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(canvas.clientWidth * DPR) || 1;
    canvas.height = Math.floor(canvas.clientHeight * DPR) || 1;
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize, { passive:true });
  resize();

  class Cube {
    constructor(x,y,size, vx, vy, color) {
      this.x = x;
      this.y = y;
      this.size = size;
      this.vx = vx;
      this.vy = vy;
      this.color = color;
      this.rotation = Math.random()*Math.PI*2;
      this.angularVel = (Math.random()-0.5)*2.0; // noticeable spin
      this.onFloor = false;
    }

    step(dt, boundsW, boundsH) {
      // apply gravity (down is +y)
      this.vy += GRAVITY * dt;

      // integrate
      this.x += this.vx * dt;
      this.y += this.vy * dt;
      this.rotation += this.angularVel * dt;

      const half = this.size/2;

      // left wall
      if (this.x - half < 0) {
        this.x = half;
        this.vx = -this.vx * WALL_RESTITUTION;
        this.angularVel *= 0.9;
      }
      // right wall
      if (this.x + half > boundsW) {
        this.x = boundsW - half;
        this.vx = -this.vx * WALL_RESTITUTION;
        this.angularVel *= 0.9;
      }
      // top
      if (this.y - half < 0) {
        this.y = half;
        this.vy = -this.vy * WALL_RESTITUTION;
        this.angularVel *= 0.9;
      }

      // bottom / floor
      if (this.y + half > boundsH) {
        // put on floor
        this.y = boundsH - half;

        // if velocity is fairly large, bounce; otherwise settle
        if (Math.abs(this.vy) > 40) {
          this.vy = -this.vy * FLOOR_RESTITUTION;
          // give a bit of angular kick based on horizontal vel
          this.angularVel += (Math.random()-0.5) * 6 * Math.sign(this.vx || 1);
          this.onFloor = false;
        } else {
          // settle on the floor
          this.vy = 0;
          this.onFloor = true;
        }

        // friction: reduce horizontal motion while on the floor
        if (this.onFloor) {
          this.vx *= FLOOR_FRICTION;
          // small threshold to zero
          if (Math.abs(this.vx) < 2) this.vx = 0;
          // damp angular velocity gradually
          this.angularVel *= 0.96;
        }
      } else {
        this.onFloor = false;
      }
    }

    draw(ctx) {
      const s = this.size;
      const x = this.x;
      const y = this.y;

      const front = this.color;
      const top = shade(front, 18);
      const right = shade(front, -18);

      ctx.save();
      ctx.translate(x, y);
      ctx.rotate(this.rotation);
      ctx.translate(-x, -y);

      const half = s/2;
      // front face
      ctx.beginPath();
      ctx.rect(x-half, y-half, s, s);
      ctx.fillStyle = front;
      ctx.fill();

      // top face
      ctx.beginPath();
      ctx.moveTo(x-half, y-half);
      ctx.lineTo(x, y-half - s*0.5);
      ctx.lineTo(x+half, y-half - s*0.5);
      ctx.lineTo(x+half, y-half);
      ctx.closePath();
      ctx.fillStyle = top;
      ctx.fill();

      // right face
      ctx.beginPath();
      ctx.moveTo(x+half, y-half);
      ctx.lineTo(x+half + s*0.5, y);
      ctx.lineTo(x+half + s*0.5, y + s);
      ctx.lineTo(x+half, y+half);
      ctx.closePath();
      ctx.fillStyle = right;
      ctx.fill();

      // subtle outline
      ctx.lineWidth = Math.max(0.6, s * 0.02);
      ctx.strokeStyle = 'rgba(0,0,0,0.2)';
      ctx.strokeRect(x-half, y-half, s, s);

      ctx.restore();
    }
  }

  function shade(hex, percent) {
    const h = hex.replace('#','');
    const r = parseInt(h.substring(0,2),16);
    const g = parseInt(h.substring(2,4),16);
    const b = parseInt(h.substring(4,6),16);
    const p = percent/100;
    const nr = Math.min(255, Math.max(0, Math.round(r + (p * 255))));
    const ng = Math.min(255, Math.max(0, Math.round(g + (p * 255))));
    const nb = Math.min(255, Math.max(0, Math.round(b + (p * 255))));
    return `rgb(${nr},${ng},${nb})`;
  }

  const palette = ['#06b6d4','#7c3aed','#ef4444','#f59e0b','#10b981','#3b82f6','#ec4899'];
  let cubes = [];

  function spawnN(n) {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    for (let i=0;i<n;i++){
      const size = 30 + Math.random()*50; // 30 - 80 px
      const x = Math.random() * (w - size) + size/2;
      const y = size/2 + 8 + Math.random()*40; // spawn near the top so gravity is visible
      const vx = (Math.random()-0.5)*300; // small lateral speed
      const vy = Math.random()*40 - 10;   // slight initial vertical offset (mostly zero)
      const color = palette[Math.floor(Math.random()*palette.length)];
      cubes.push(new Cube(x,y,size,vx,vy,color));
    }
    updateCounters();
  }

  // UI
  const spawnBtn = document.getElementById('spawnBtn');
  const countLabel = document.getElementById('countLabel');
  const fpsLabel = document.getElementById('fpsLabel');

  spawnBtn.addEventListener('click', () => {
    spawnN(10);
  });

  function updateCounters() {
    countLabel.textContent = `Cubes: ${cubes.length}`;
  }

  // main loop
  let last = performance.now();
  let fpsSmoothed = 60;
  function loop(now) {
    const dt = Math.min(0.05, (now - last) / 1000); // clamp large dt
    last = now;

    const w = canvas.clientWidth;
    const h = canvas.clientHeight;

    // physics
    for (let c of cubes) c.step(dt, w, h);

    // clear
    ctx.clearRect(0,0, canvas.width, canvas.height);

    // background
    drawBackground(ctx, w, h);

    // draw cubes (sort by y for basic depth)
    cubes.sort((a,b)=> (a.y - b.y));
    for (let c of cubes) c.draw(ctx);

    // fps
    const fps = 1 / dt;
    fpsSmoothed = fpsSmoothed * 0.92 + fps * 0.08;
    fpsLabel.textContent = `FPS: ${Math.round(fpsSmoothed)}`;

    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function drawBackground(ctx, w, h) {
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,'rgba(6,7,23,0.6)');
    g.addColorStop(1,'rgba(2,6,23,0.9)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,w,h);

    // subtle vignette
    const rad = Math.max(w,h) * 0.8;
    const vg = ctx.createRadialGradient(w/2,h/2, rad*0.02, w/2,h/2, rad);
    vg.addColorStop(0, 'rgba(255,255,255,0.0)');
    vg.addColorStop(0.7, 'rgba(0,0,0,0.06)');
    vg.addColorStop(1, 'rgba(0,0,0,0.25)');
    ctx.fillStyle = vg;
    ctx.fillRect(0,0,w,h);
  }

  function measureStageAndResizeCanvas(){ resize(); }
  window.addEventListener('load', measureStageAndResizeCanvas);
  measureStageAndResizeCanvas();

  // double-click to clear cubes
  window.addEventListener('dblclick', () => {
    cubes = [];
    updateCounters();
  });

  // helpful keyboard shortcuts
  window.addEventListener('keydown', (e) => {
    if (e.key === 'c') { cubes = []; updateCounters(); } // clear
    if (e.key === 's') { spawnN(10); } // spawn
  });

})();
</script>
</body>
</html>
