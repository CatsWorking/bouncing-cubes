<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Bouncing Cubes — Sandbox</title>
<style>
  html,body { height:100%; margin:0; font-family: Inter, Roboto, Arial, sans-serif;
    background: linear-gradient(180deg, #0f172a 0%, #071027 100%); color: #fff; }

  .stage { position: relative; width: 100%; height: 100vh; overflow: hidden; }
  .center-btn {
    position: absolute; left: 50%; top: 50%; transform: translate(-50%,-50%);
    z-index: 20; padding: 14px 22px; border-radius: 12px;
    background: linear-gradient(135deg,#06b6d4,#7c3aed);
    color: white; font-weight:600; cursor: pointer; border: none;
  }
  .credit {
    position: absolute; left: 50%; top: calc(50% + 60px); transform: translateX(-50%);
    z-index: 20; font-size: 14px; color: rgba(255,255,255,0.75); text-align: center;
    max-width: 80%;
  }
  .controls {
    position: absolute; z-index: 25; left: 12px; top: 12px; display:flex; gap:10px;
    align-items:center; background: rgba(0,0,0,0.35); padding:8px 12px; border-radius:10px;
    backdrop-filter: blur(6px);
  }
  .control { font-size:13px; }
  .attribution {
    position: absolute; bottom: 12px; right: 12px; color: rgba(255,255,255,0.6);
    font-size: 12px; z-index:20;
  }
  .draw-controls {
    position: absolute; bottom: 12px; right: 12px; z-index: 30;
    background: rgba(0,0,0,0.5); padding: 10px; border-radius: 10px;
    display: flex; flex-direction: column; gap: 8px;
  }
  canvas { display:block; width:100%; height:100%; cursor: crosshair; }
  input[type="range"] { width:100px; }
</style>
</head>
<body>
  <div class="stage">
    <button id="spawnBtn" class="center-btn">Spawn 10 Cubes</button>
    <div class="credit">made by sushi [thx jj for the nickname] or br33z3 as i call myself online</div>

    <div class="controls">
      <div class="control" id="countLabel">Cubes: 0</div>
      <div class="control" id="fpsLabel">FPS: 0</div>
      <div class="control">Gravity:
        <input id="gravitySlider" type="range" min="200" max="8000" value="3000" step="100">
      </div>
    </div>

    <div class="attribution">Click button to spawn cubes — they fall, bounce, and collide.</div>
    <canvas id="c"></canvas>

    <div class="draw-controls">
      <button id="toggleDraw">Enable Collision Drawing Mode</button>
      <div id="drawTools" style="display:none;">
        <label>Brush size: <input type="range" id="brushSize" min="2" max="40" value="10"></label>
        <label>Color: <input type="color" id="brushColor" value="#ffffff"></label>
      </div>
    </div>
  </div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: true });

  let GRAVITY = 3000;
  const FLOOR_RESTITUTION = 0.72;
  const WALL_RESTITUTION = 0.85;
  const FLOOR_FRICTION = 0.995;

  const slider = document.getElementById("gravitySlider");
  slider.addEventListener("input", () => { GRAVITY = parseFloat(slider.value); });

  let DPR = Math.max(1, window.devicePixelRatio || 1);
  function resize() {
    DPR = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.floor(canvas.clientWidth * DPR) || 1;
    canvas.height = Math.floor(canvas.clientHeight * DPR) || 1;
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  class Cube {
    constructor(x,y,size, vx, vy, color) {
      this.x = x; this.y = y; this.size = size;
      this.vx = vx; this.vy = vy; this.color = color;
      this.rotation = Math.random()*Math.PI*2;
      this.angularVel = (Math.random()-0.5)*2.0;
    }
    step(dt, boundsW, boundsH, lines) {
      this.vy += GRAVITY * dt;
      this.x += this.vx * dt; this.y += this.vy * dt;
      this.rotation += this.angularVel * dt;
      const half = this.size/2;
      if (this.x - half < 0) { this.x = half; this.vx = -this.vx * WALL_RESTITUTION; }
      if (this.x + half > boundsW) { this.x = boundsW - half; this.vx = -this.vx * WALL_RESTITUTION; }
      if (this.y - half < 0) { this.y = half; this.vy = -this.vy * WALL_RESTITUTION; }
      if (this.y + half > boundsH) {
        this.y = boundsH - half;
        if (Math.abs(this.vy) > 40) { this.vy = -this.vy * FLOOR_RESTITUTION; }
        else { this.vy = 0; }
        this.vx *= FLOOR_FRICTION;
      }
      // collisions with drawn lines
      for (let line of lines) {
        if (lineCollision(this, line)) {
          this.vy = -this.vy * 0.7;
          this.vx *= 0.8;
        }
      }
    }
    draw(ctx) {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.rotation);
      ctx.translate(-this.x, -this.y);
      ctx.fillStyle = this.color;
      ctx.fillRect(this.x-this.size/2, this.y-this.size/2, this.size, this.size);
      ctx.restore();
    }
  }

  function lineCollision(cube, line) {
    const {x,y,size} = cube;
    const half = size/2;
    const cx = x, cy = y;
    const nearestX = Math.max(Math.min(cx, Math.max(line.x1,line.x2)), Math.min(line.x1,line.x2));
    const nearestY = Math.max(Math.min(cy, Math.max(line.y1,line.y2)), Math.min(line.y1,line.y2));
    const dx = cx - nearestX, dy = cy - nearestY;
    return (dx*dx + dy*dy) < (half*half);
  }

  const palette = ['#06b6d4','#7c3aed','#ef4444','#f59e0b','#10b981','#3b82f6','#ec4899'];
  let cubes = [];
  let lines = [];

  function spawnN(n) {
    const w = canvas.clientWidth;
    for (let i=0;i<n;i++){
      const size = 30 + Math.random()*50;
      const x = Math.random() * (w - size) + size/2;
      const y = size/2 + Math.random()*40;
      const vx = (Math.random()-0.5)*200;
      const vy = 0;
      const color = palette[Math.floor(Math.random()*palette.length)];
      cubes.push(new Cube(x,y,size,vx,vy,color));
    }
    countLabel.textContent = `Cubes: ${cubes.length}`;
  }

  const spawnBtn = document.getElementById('spawnBtn');
  const countLabel = document.getElementById('countLabel');
  const fpsLabel = document.getElementById('fpsLabel');
  spawnBtn.addEventListener('click', () => spawnN(10));

  // Drawing mode
  const toggleDraw = document.getElementById("toggleDraw");
  const drawTools = document.getElementById("drawTools");
  const brushSize = document.getElementById("brushSize");
  const brushColor = document.getElementById("brushColor");
  let drawingMode = false, drawing = false, lastX=0,lastY=0;

  toggleDraw.addEventListener("click",()=>{
    drawingMode = !drawingMode;
    drawTools.style.display = drawingMode ? "flex":"none";
    toggleDraw.textContent = drawingMode ? "Disable Drawing Mode":"Enable Collision Drawing Mode";
  });

  canvas.addEventListener("mousedown", e=>{
    if (!drawingMode) return;
    drawing = true; [lastX,lastY] = [e.offsetX,e.offsetY];
  });
  canvas.addEventListener("mouseup", ()=> drawing=false);
  canvas.addEventListener("mouseleave", ()=> drawing=false);
  canvas.addEventListener("mousemove", e=>{
    if (!drawingMode || !drawing) return;
    const [x,y] = [e.offsetX,e.offsetY];
    ctx.strokeStyle = brushColor.value;
    ctx.lineWidth = brushSize.value;
    ctx.lineCap = "round";
    ctx.beginPath(); ctx.moveTo(lastX,lastY); ctx.lineTo(x,y); ctx.stroke();
    lines.push({x1:lastX,y1:lastY,x2:x,y2:y});
    [lastX,lastY] = [x,y];
  });

  let last = performance.now(), fpsSmoothed = 60;
  function loop(now) {
    const dt = Math.min(0.05, (now - last) / 1000);
    last = now;
    const w = canvas.clientWidth, h = canvas.clientHeight;

    for (let c of cubes) c.step(dt, w, h, lines);

    ctx.clearRect(0,0, canvas.width, canvas.height);
    drawBackground(ctx, w, h);
    cubes.sort((a,b)=>a.y-b.y);
    for (let c of cubes) c.draw(ctx);

    const fps = 1/dt;
    fpsSmoothed = fpsSmoothed*0.92 + fps*0.08;
    fpsLabel.textContent = `FPS: ${Math.round(fpsSmoothed)}`;
    requestAnimationFrame(loop);
  }
  requestAnimationFrame(loop);

  function drawBackground(ctx,w,h){
    const g = ctx.createLinearGradient(0,0,0,h);
    g.addColorStop(0,'rgba(6,7,23,0.6)');
    g.addColorStop(1,'rgba(2,6,23,0.9)');
    ctx.fillStyle = g; ctx.fillRect(0,0,w,h);
  }
})();
</script>
</body>
</html>
